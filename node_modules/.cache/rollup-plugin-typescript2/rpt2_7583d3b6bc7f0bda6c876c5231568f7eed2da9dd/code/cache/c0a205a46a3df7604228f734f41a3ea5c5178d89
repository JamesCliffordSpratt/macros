{"code":"import { __awaiter } from \"tslib\";\nimport { Notice, Plugin } from 'obsidian';\nimport { mergeMacroLines, extractServingSize, extractNutritionalData, parseGrams, processNutritionalData, renderMacronutrientPieChart, createPieChartLegend, normalizeName } from './utils';\nimport { FoodSearchModal, FoodResultsModal } from './modals';\nimport { NutritionalSettingTab, DEFAULT_SETTINGS } from './settings';\n/*\n * Macros Plugin\n * -------------------------\n * This plugin integrates nutritional data fetching and processing into Obsidian.\n * It handles API communication with FatSecret, file caching, sequential updates,\n * and custom markdown processing for nutritional calculations.\n *\n * Architecture Overview:\n * - main.ts: Core plugin initialization, event registration, and acting as the central hub.\n * - modals.ts: User interface components (dialogs/modals) for various interactions.\n * - processors.ts: Custom markdown code block processors for rendering nutritional data.\n * - settings.ts: Plugin settings and the settings UI.\n * - utils.ts: Helper functions for data parsing, merging, and extraction.\n * - api.ts: External API integration using OAuth (FatSecret API).\n *\n * NOTE on API Credentials:\n * These API credentials are encoded (using Base64) to obfuscate the plain-text values\n * in the source code. FatSecret has permitted these credentials for open-source usage in\n * this free plugin. While this method adds a minor barrier against casual inspection,\n * it is not equivalent to full encryption.\n */\n// @ts-ignore\nconst OAuth = require('oauth-1.0a');\n// Encoded credentials, decoded at runtime.\nconst ENCODED_API_KEY = 'NDQzMGMzYzgyOGMwNDkwN2JjOGI1NTk0MTg0MzU2NzM=';\nconst ENCODED_API_SECRET = 'M2MxNjQyZjE5ZjhhNDU2Njg0ZDlmNGQ0Njc0NjYxOTQ=';\nfunction decodeCredential(encoded) {\n    return Buffer.from(encoded, 'base64').toString('utf8').trim();\n}\nconst FAT_SECRET_API_KEY = decodeCredential(ENCODED_API_KEY);\nconst FAT_SECRET_API_SECRET = decodeCredential(ENCODED_API_SECRET);\n// Constant used for interactive lines in macros blocks.\nconst INTERACTIVE_PREFIX = \"interactive:\";\nexport default class MacrosPlugin extends Plugin {\n    constructor() {\n        super(...arguments);\n        // Holds additional interactive macros lines per table id.\n        this.additionalMacros = new Map();\n        // Global map to store macros table data by unique id.\n        this.macroTables = new Map();\n        // Map of macrospc (pie-chart) container elements by macro id.\n        this.macrospcContainers = new Map();\n        // Set to store macroscalc container elements.\n        this.macrocalcContainers = new Set();\n        // --- CONCURRENCY LOCK: A simple update mutex to serialize file modifications ---\n        this.updateMutex = Promise.resolve();\n        // --- FILE CACHE: Cache mapping from folder path to list of files ---\n        this.fileCache = new Map();\n    }\n    getDefaultApiKey() {\n        return FAT_SECRET_API_KEY;\n    }\n    getDefaultApiSecret() {\n        return FAT_SECRET_API_SECRET;\n    }\n    /**\n     * Returns the list of files in the given folder, using a cache for performance.\n     */\n    getFilesInFolder(folder) {\n        const cached = this.fileCache.get(folder);\n        if (cached !== undefined)\n            return cached;\n        const allFiles = this.app.vault.getFiles();\n        const filtered = allFiles.filter(f => f.path.startsWith(folder));\n        this.fileCache.set(folder, filtered);\n        return filtered;\n    }\n    /**\n     * Invalidates the file cache. Call this on file modifications.\n     */\n    invalidateFileCache() {\n        this.fileCache.clear();\n    }\n    /**\n     * Enqueues an update function to serialize file modifications.\n     * Uses a promise-based mutex (updateMutex) to prevent race conditions.\n     * @param updateFn A function that returns a Promise<void> with the update logic.\n     * @returns A Promise that resolves when the queued update has completed.\n     */\n    queueUpdate(updateFn) {\n        const timeoutPromise = new Promise((_resolve, reject) => {\n            setTimeout(() => reject(new Error(\"Update timed out\")), 30000);\n        });\n        this.updateMutex = this.updateMutex.then(() => Promise.race([updateFn(), timeoutPromise]).catch((error) => {\n            console.error(\"Error during queued update (or update timed out):\", error);\n        }));\n        return this.updateMutex;\n    }\n    /**\n     * Creates a reusable callback function for handling selected food items\n     */\n    createFoodItemCallback() {\n        return (selectedFood) => __awaiter(this, void 0, void 0, function* () {\n            const servingSize = extractServingSize(selectedFood.food_description);\n            const nutritionalData = extractNutritionalData(selectedFood.food_description);\n            const fileName = `${selectedFood.food_name}.md`;\n            const frontmatter = `---\r\ncalories: ${nutritionalData.calories}\r\nprotein: ${nutritionalData.protein}\r\nfat: ${nutritionalData.fat}\r\ncarbs: ${nutritionalData.carbs}\r\nserving_size: ${servingSize}\r\n---\\n`;\n            try {\n                yield this.app.vault.create(`${this.settings.storageFolder}/${fileName}`, frontmatter);\n                new Notice(`Saved ${fileName}`);\n            }\n            catch (error) {\n                console.error('Error creating food file:', error);\n                new Notice(`Error saving ${fileName}`);\n            }\n        });\n    }\n    onload() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.loadSettings();\n            this.nutritionalSettingTab = new NutritionalSettingTab(this.app, this);\n            this.addSettingTab(this.nutritionalSettingTab);\n            // Invalidate file cache on file modifications.\n            this.registerEvent(this.app.vault.on('modify', () => this.invalidateFileCache()));\n            this.registerEvent(this.app.vault.on('create', () => this.invalidateFileCache()));\n            this.registerEvent(this.app.vault.on('delete', () => this.invalidateFileCache()));\n            this.registerEvent(this.app.vault.on('rename', () => this.invalidateFileCache()));\n            // Ribbon icon opens the Food Search modal.\n            this.addRibbonIcon('apple', 'Search for Food (FatSecret)', () => {\n                new FoodSearchModal(this.app, (searchTerm) => {\n                    // Use user provided API credentials if available; otherwise, fallback to defaults.\n                    const apiKey = this.settings.fatSecretApiKey && this.settings.fatSecretApiKey.trim() !== \"\"\n                        ? this.settings.fatSecretApiKey.trim()\n                        : FAT_SECRET_API_KEY;\n                    const apiSecret = this.settings.fatSecretApiSecret && this.settings.fatSecretApiSecret.trim() !== \"\"\n                        ? this.settings.fatSecretApiSecret.trim()\n                        : FAT_SECRET_API_SECRET;\n                    new FoodResultsModal(this.app, searchTerm, apiKey, apiSecret, this.createFoodItemCallback()).open();\n                }).open();\n            });\n            // Register a command to search for food.\n            this.addCommand({\n                id: 'search-food',\n                name: 'Search for Food (FatSecret)',\n                callback: () => {\n                    new FoodSearchModal(this.app, (searchTerm) => {\n                        // Retrieve API credentials from settings, falling back if necessary.\n                        const apiKey = this.settings.fatSecretApiKey && this.settings.fatSecretApiKey.trim() !== \"\"\n                            ? this.settings.fatSecretApiKey.trim()\n                            : FAT_SECRET_API_KEY;\n                        const apiSecret = this.settings.fatSecretApiSecret && this.settings.fatSecretApiSecret.trim() !== \"\"\n                            ? this.settings.fatSecretApiSecret.trim()\n                            : FAT_SECRET_API_SECRET;\n                        new FoodResultsModal(this.app, searchTerm, apiKey, apiSecret, this.createFoodItemCallback()).open();\n                    }).open();\n                },\n            });\n            // REGISTER MARKDOWN CODE-BLOCK PROCESSORS FROM processors.ts\n            import('./processors').then(module => {\n                module.registerProcessors(this);\n            });\n        });\n    }\n    /**\n     * Renders a pie chart representing the macronutrient breakdown for a given macros table.\n     * @param id The table identifier.\n     * @param el The HTML element in which to render the chart.\n     */\n    drawMacrospc(id, el) {\n        el.empty();\n        const canvas = el.createEl('canvas', { attr: { width: '300', height: '300' } });\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            el.createEl('div', { text: 'Error: Unable to get canvas context.' });\n            return;\n        }\n        if (this.macroTables.has(id)) {\n            const macroLines = this.macroTables.get(id);\n            let totalProtein = 0;\n            let totalFat = 0;\n            let totalCarbs = 0;\n            // Process each line of the macros table\n            macroLines.forEach(line => {\n                if (line.toLowerCase().startsWith('meal:')) {\n                    // Extract meal name and count if present\n                    const fullMealText = line.substring(5).trim();\n                    let mealName = fullMealText;\n                    let count = 1;\n                    // Check if there's a count indicator\n                    const countMatch = fullMealText.match(/^(.*)\\s+Ã—\\s+(\\d+)$/);\n                    if (countMatch) {\n                        mealName = countMatch[1];\n                        count = parseInt(countMatch[2]);\n                    }\n                    const meal = this.settings.mealTemplates.find(m => m.name.toLowerCase() === mealName.toLowerCase());\n                    if (!meal)\n                        return;\n                    meal.items.forEach((item) => {\n                        let foodQuery = item;\n                        let specifiedQuantity = null;\n                        if (item.includes(':')) {\n                            const parts = item.split(':').map(s => s.trim());\n                            foodQuery = parts[0];\n                            specifiedQuantity = parseGrams(parts[1]);\n                            // Apply multiplier if count > 1\n                            if (count > 1 && specifiedQuantity !== null) {\n                                specifiedQuantity = specifiedQuantity * count;\n                            }\n                        }\n                        // Process the food item and get its nutritional data\n                        const matchingFile = this.findFoodFile(foodQuery);\n                        if (!matchingFile)\n                            return;\n                        const nutrition = processNutritionalData(this.app, matchingFile, specifiedQuantity);\n                        if (!nutrition)\n                            return;\n                        totalProtein += nutrition.protein;\n                        totalFat += nutrition.fat;\n                        totalCarbs += nutrition.carbs;\n                    });\n                }\n                else {\n                    let foodQuery = line;\n                    let specifiedQuantity = null;\n                    if (line.includes(':')) {\n                        const parts = line.split(':').map(s => s.trim());\n                        foodQuery = parts[0];\n                        specifiedQuantity = parseGrams(parts[1]);\n                    }\n                    // Process the food item and get its nutritional data\n                    const matchingFile = this.findFoodFile(foodQuery);\n                    if (!matchingFile)\n                        return;\n                    const nutrition = processNutritionalData(this.app, matchingFile, specifiedQuantity);\n                    if (!nutrition)\n                        return;\n                    totalProtein += nutrition.protein;\n                    totalFat += nutrition.fat;\n                    totalCarbs += nutrition.carbs;\n                }\n            });\n            const sumMacros = totalProtein + totalFat + totalCarbs;\n            if (sumMacros <= 0) {\n                el.createEl('div', { text: `No macros found for ID: ${id}` });\n                return;\n            }\n            // Render the pie chart\n            const proteinColor = this.settings.proteinColor;\n            const fatColor = this.settings.fatColor;\n            const carbsColor = this.settings.carbsColor;\n            const slices = [\n                { label: 'Protein', value: totalProtein, color: proteinColor },\n                { label: 'Fat', value: totalFat, color: fatColor },\n                { label: 'Carbs', value: totalCarbs, color: carbsColor },\n            ];\n            const success = renderMacronutrientPieChart(ctx, totalProtein, totalFat, totalCarbs, proteinColor, fatColor, carbsColor);\n            if (!success) {\n                el.createEl('div', { text: `No valid macronutrient data found for ID: ${id}` });\n                return;\n            }\n            // Create the legend\n            createPieChartLegend(el, slices);\n        }\n        else {\n            el.createEl('div', { text: 'No macro table found for the given id.' });\n        }\n    }\n    /**\n     * Helper method to find a food file in the storage folder\n     */\n    findFoodFile(foodQuery) {\n        const folder = this.settings.storageFolder;\n        const files = this.getFilesInFolder(folder);\n        const file = files.find(f => normalizeName(f.name.replace(/\\.md$/, '')) === normalizeName(foodQuery));\n        return file || null; // Convert undefined to null\n    }\n    /**\n     * Draws a combined pie chart from multiple macro table IDs.\n     * @param ids An array of table IDs.\n     * @param el The HTML element in which to render the chart.\n     */\n    drawCombinedMacrospc(ids, el) {\n        el.empty();\n        const canvas = el.createEl('canvas', { attr: { width: '300', height: '300' } });\n        const ctx = canvas.getContext('2d');\n        if (!ctx) {\n            el.createEl('div', { text: 'Error: Unable to get canvas context.' });\n            return;\n        }\n        let totalProtein = 0;\n        let totalFat = 0;\n        let totalCarbs = 0;\n        // Process each macro table ID\n        ids.forEach(id => {\n            const macroLines = this.macroTables.get(id);\n            if (!macroLines)\n                return;\n            macroLines.forEach(line => {\n                if (line.toLowerCase().startsWith('meal:')) {\n                    // Extract meal name and count if present\n                    const fullMealText = line.substring(5).trim();\n                    let mealName = fullMealText;\n                    let count = 1;\n                    // Check if there's a count indicator\n                    const countMatch = fullMealText.match(/^(.*)\\s+Ã—\\s+(\\d+)$/);\n                    if (countMatch) {\n                        mealName = countMatch[1];\n                        count = parseInt(countMatch[2]);\n                    }\n                    const meal = this.settings.mealTemplates.find(m => m.name.toLowerCase() === mealName.toLowerCase());\n                    if (!meal)\n                        return;\n                    meal.items.forEach(item => {\n                        let foodQuery = item;\n                        let specifiedQuantity = null;\n                        if (item.includes(':')) {\n                            const parts = item.split(':').map(s => s.trim());\n                            foodQuery = parts[0];\n                            specifiedQuantity = parseGrams(parts[1]);\n                            // Apply multiplier if count > 1\n                            if (count > 1 && specifiedQuantity !== null) {\n                                specifiedQuantity = specifiedQuantity * count;\n                            }\n                        }\n                        // Process the food item and get its nutritional data\n                        const matchingFile = this.findFoodFile(foodQuery);\n                        if (!matchingFile)\n                            return;\n                        const nutrition = processNutritionalData(this.app, matchingFile, specifiedQuantity);\n                        if (!nutrition)\n                            return;\n                        totalProtein += nutrition.protein;\n                        totalFat += nutrition.fat;\n                        totalCarbs += nutrition.carbs;\n                    });\n                }\n                else {\n                    let foodQuery = line;\n                    let specifiedQuantity = null;\n                    if (line.includes(':')) {\n                        const parts = line.split(':').map(s => s.trim());\n                        foodQuery = parts[0];\n                        specifiedQuantity = parseGrams(parts[1]);\n                    }\n                    // Process the food item and get its nutritional data\n                    const matchingFile = this.findFoodFile(foodQuery);\n                    if (!matchingFile)\n                        return;\n                    const nutrition = processNutritionalData(this.app, matchingFile, specifiedQuantity);\n                    if (!nutrition)\n                        return;\n                    totalProtein += nutrition.protein;\n                    totalFat += nutrition.fat;\n                    totalCarbs += nutrition.carbs;\n                }\n            });\n        });\n        const sumMacros = totalProtein + totalFat + totalCarbs;\n        if (sumMacros <= 0) {\n            el.createEl('div', { text: `No macros found for the specified IDs: ${ids.join(\", \")}` });\n            return;\n        }\n        // Render the pie chart\n        const proteinColor = this.settings.proteinColor;\n        const fatColor = this.settings.fatColor;\n        const carbsColor = this.settings.carbsColor;\n        const slices = [\n            { label: 'Protein', value: totalProtein, color: proteinColor },\n            { label: 'Fat', value: totalFat, color: fatColor },\n            { label: 'Carbs', value: totalCarbs, color: carbsColor },\n        ];\n        const success = renderMacronutrientPieChart(ctx, totalProtein, totalFat, totalCarbs, proteinColor, fatColor, carbsColor);\n        if (!success) {\n            el.createEl('div', { text: `No valid macronutrient data found for the specified IDs: ${ids.join(\", \")}` });\n            return;\n        }\n        // Create the legend\n        createPieChartLegend(el, slices);\n    }\n    /**\n     * Loads the macros table from the vault by searching markdown files.\n     * Filters out bullet points to ensure proper merging.\n     * @param id The macros table identifier.\n     * @returns A Promise resolving to an array of macro line strings or null if not found.\n     */\n    loadMacroTableFromVault(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const mdFiles = this.app.vault.getFiles().filter(file => file.extension === 'md');\n            const regex = new RegExp(\"```\\\\s*macros\\\\s+id:\\\\s*\" + id + \"\\\\s*\\\\n([\\\\s\\\\S]*?)```\", \"m\");\n            for (const file of mdFiles) {\n                try {\n                    const content = yield this.app.vault.read(file);\n                    const match = content.match(regex);\n                    if (match) {\n                        // Filter out the bullet points\n                        const tableLines = match[1].split(\"\\n\")\n                            .map(line => line.trim())\n                            .filter(line => line !== '' && !line.startsWith('-'));\n                        console.log(`Loading macroTable for id ${id}:`, tableLines);\n                        return tableLines;\n                    }\n                }\n                catch (error) {\n                    console.error(`Error reading file ${file.path} for macros table:`, error);\n                }\n            }\n            return null;\n        });\n    }\n    /**\n     * Updates the global macro table cache by parsing macros blocks from the provided content.\n     * Only stores non-bullet-point lines to ensure proper merging.\n     * @param content The full file content to search for macros blocks.\n     */\n    updateGlobalMacroTableFromContent(content) {\n        console.log(\"updateGlobalMacroTableFromContent called\");\n        try {\n            const regex = /```[\\t ]*macros[\\t ]+id:[\\t ]*(\\S+)[\\t ]*\\n([\\s\\S]*?)```/g;\n            let match;\n            let updated = false;\n            while ((match = regex.exec(content)) !== null) {\n                const id = match[1];\n                // Filter out the bullet points when storing in the macro tables\n                const blockContent = match[2].trim().split(\"\\n\")\n                    .map(l => l.trim())\n                    .filter(l => l !== '' && !l.startsWith('-'));\n                console.log(`Updating macroTables for id ${id} with ${blockContent.length} lines:`, blockContent);\n                this.macroTables.set(id, blockContent);\n                updated = true;\n            }\n            // If we updated any tables, log that for debugging\n            if (updated) {\n                console.log(\"macroTables updated successfully\");\n                // Debug: log the content of all tables\n                for (const [id, lines] of this.macroTables.entries()) {\n                    console.log(`Current macroTable[${id}]:`, lines);\n                }\n            }\n        }\n        catch (error) {\n            console.error(\"Error updating global macro table from content:\", error);\n        }\n    }\n    /**\n     * Updates the macros code block in the active file by merging static and interactive lines.\n     * Also refreshes global macro tables and triggers re-rendering of markdown views.\n     */\n    updateMacrosCodeBlock() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(\"updateMacrosCodeBlock called\");\n            yield this.queueUpdate(() => __awaiter(this, void 0, void 0, function* () {\n                const activeFile = this.app.workspace.getActiveFile();\n                if (!activeFile)\n                    return;\n                try {\n                    let content = yield this.app.vault.read(activeFile);\n                    const regex = /```macros\\s+id:\\s*(\\S+)\\s*([\\s\\S]*?)```/g;\n                    let newContent = content.replace(regex, (match, id, blockContent) => {\n                        console.log(`Processing block with id ${id}`);\n                        // First, collect all lines including removing interactive prefix\n                        let allLines = [];\n                        // Process existing content in the block (ignoring bullet points)\n                        const staticLines = blockContent.split(\"\\n\")\n                            .map((l) => l.trim())\n                            .filter((l) => l !== \"\" && !l.startsWith(INTERACTIVE_PREFIX) && !l.startsWith(\"-\"));\n                        console.log(`Static lines from block (${staticLines.length}):`, staticLines);\n                        allLines = [...staticLines];\n                        // Get interactive lines from the map\n                        const interactiveLines = (this.additionalMacros.get(id) || []).map((line) => line.startsWith(INTERACTIVE_PREFIX) ? line.substring(INTERACTIVE_PREFIX.length) : line);\n                        console.log(`Interactive lines (${interactiveLines.length}):`, interactiveLines);\n                        // Add them to the collection\n                        allLines = [...allLines, ...interactiveLines];\n                        console.log(`Combined lines for merging (${allLines.length}):`, allLines);\n                        // Merge duplicate meal entries and food items\n                        const mergedLines = mergeMacroLines(allLines);\n                        console.log(`Merged lines (${mergedLines.length}):`, mergedLines);\n                        // Now expand the meal templates after the merging is complete\n                        let expandedContent = \"\";\n                        mergedLines.forEach((line) => {\n                            if (line.toLowerCase().startsWith(\"meal:\")) {\n                                // Extract meal name and potential multiplier\n                                const fullMealText = line.substring(5).trim();\n                                let mealName = fullMealText;\n                                let count = 1;\n                                // Check if there's a count indicator\n                                const countMatch = fullMealText.match(/^(.*)\\s+Ã—\\s+(\\d+)$/);\n                                if (countMatch) {\n                                    mealName = countMatch[1];\n                                    count = parseInt(countMatch[2]);\n                                    console.log(`Expanding meal ${mealName} with count ${count}`);\n                                }\n                                const meal = this.settings.mealTemplates.find(m => m.name.toLowerCase() === mealName.toLowerCase());\n                                if (meal && meal.items.length > 0) {\n                                    expandedContent += line + \"\\n\";\n                                    // Add meal items with calculated quantities\n                                    meal.items.forEach(item => {\n                                        const parts = item.split(':');\n                                        if (parts.length > 1 && parts[1].includes('g')) {\n                                            // Extract the serving size and multiply by count\n                                            const servingMatch = parts[1].match(/^([\\d\\.]+)g/);\n                                            if (servingMatch) {\n                                                const serving = parseFloat(servingMatch[1]);\n                                                const multipliedServing = serving * count;\n                                                expandedContent += `- ${parts[0]}:${multipliedServing}g\\n`;\n                                                console.log(`Added: - ${parts[0]}:${multipliedServing}g`);\n                                            }\n                                            else {\n                                                expandedContent += `- ${item}\\n`;\n                                            }\n                                        }\n                                        else {\n                                            expandedContent += `- ${item}\\n`;\n                                        }\n                                    });\n                                }\n                                else {\n                                    expandedContent += line + \"\\n\";\n                                }\n                            }\n                            else {\n                                expandedContent += line + \"\\n\";\n                            }\n                        });\n                        // Clear interactive lines after merging\n                        this.additionalMacros.set(id, []);\n                        return \"```macros\\nid: \" + id + \"\\n\" + expandedContent + \"\\n```\";\n                    });\n                    yield this.app.vault.modify(activeFile, newContent);\n                    // Update the global macro tables with the latest content\n                    this.updateGlobalMacroTableFromContent(newContent);\n                    this.additionalMacros.clear();\n                    // Must trigger metadata changes to force refresh\n                    this.app.metadataCache.trigger(\"changed\", activeFile);\n                    // Force refresh all views\n                    this.refreshMarkdownViews();\n                    yield this.redrawAllMacrospc();\n                    yield this.redrawAllMacrocalc();\n                }\n                catch (error) {\n                    console.error(\"Error updating macros code block:\", error);\n                }\n            }));\n        });\n    }\n    /**\n     * Iterates over all macrospc container elements and redraws their charts.\n     */\n    redrawAllMacrospc() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const [id, containerSet] of this.macrospcContainers.entries()) {\n                try {\n                    const loaded = yield this.loadMacroTableFromVault(id);\n                    if (loaded) {\n                        this.macroTables.set(id, loaded);\n                    }\n                }\n                catch (error) {\n                    console.error(`Error re-loading macro table for id ${id}:`, error);\n                }\n                // Remove stale elements (not connected to DOM)\n                const aliveElements = new Set();\n                containerSet.forEach(el => {\n                    if (el.isConnected) {\n                        this.drawMacrospc(id, el);\n                        aliveElements.add(el);\n                    }\n                });\n                this.macrospcContainers.set(id, aliveElements);\n            }\n        });\n    }\n    /**\n     * Triggers a refresh of all markdown views.\n     */\n    redrawAllMacrocalc() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.refreshMarkdownViews();\n        });\n    }\n    /**\n     * Refreshes all active markdown views, triggering a re-render.\n     */\n    refreshMarkdownViews() {\n        this.app.workspace.getLeavesOfType(\"markdown\").forEach(leaf => {\n            const view = leaf.view;\n            if (view.previewMode && typeof view.previewMode.rerender === \"function\") {\n                view.previewMode.rerender(true);\n            }\n            else {\n                leaf.setViewState(leaf.getViewState());\n            }\n        });\n    }\n    /**\n     * Loads plugin settings.\n     */\n    loadSettings() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());\n        });\n    }\n    /**\n     * Saves plugin settings.\n     */\n    saveSettings() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.saveData(this.settings);\n        });\n    }\n}\n","references":["C:/Users/James/Desktop/obsidian-macros-plugin/types/obsidian.d.ts","C:/Users/James/Desktop/obsidian-macros-plugin/node_modules/@types/crypto-js/index.d.ts","C:/Users/James/Desktop/obsidian-macros-plugin/utils.ts","C:/Users/James/Desktop/obsidian-macros-plugin/api.ts","C:/Users/James/Desktop/obsidian-macros-plugin/modals.ts","C:/Users/James/Desktop/obsidian-macros-plugin/settings.ts","C:/Users/James/Desktop/obsidian-macros-plugin/processors.ts"]}
