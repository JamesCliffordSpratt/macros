{"code":"import { TFolder } from 'obsidian';\n/*\n * Utility Functions for Macros Plugin\n * -----------------------------------------------\n * Includes helper functions used across the plugin:\n *  - getVaultFolders: Retrieves all folder paths in the vault.\n *  - mergeMacroLines: Merges duplicate food lines by summing their serving sizes.\n *  - extractServingSize: Extracts a serving size from a food description.\n *  - extractNutritionalData: Parses calories, protein, fat, and carbs from food descriptions.\n *  - parseGrams: Extracts a numeric value (in grams) from a text string.\n *  - findMatchingFoodFile: Find food file based on query.\n *  - processNutritionalData: Process nutritional data for a food item.\n */\nexport function getVaultFolders(app) {\n    const folders = [];\n    const traverse = (folder) => {\n        folders.push(folder.path);\n        folder.children.forEach(child => {\n            if (child instanceof TFolder) {\n                traverse(child);\n            }\n        });\n    };\n    traverse(app.vault.getRoot());\n    return folders.sort();\n}\n/**\n * Merges multiple macro lines that reference the same food item by summing their serving sizes.\n * Also merges multiple instances of the same meal template with a count.\n * Example: Two entries \"Apple: 100g\" become \"Apple:200g\".\n * Example: Two entries \"meal:Breakfast\" become \"meal:Breakfast × 2\".\n * @param lines An array of macro line strings.\n * @returns An array of merged macro line strings.\n */\nexport function mergeMacroLines(lines) {\n    console.log(\"mergeMacroLines input:\", lines);\n    const mergedFood = {};\n    const mergedMeals = {};\n    lines.forEach((line, index) => {\n        if (line.toLowerCase().startsWith(\"meal:\")) {\n            // Extract the meal name (ignore any existing count marker)\n            const fullMealText = line.substring(5).trim();\n            let mealName = fullMealText;\n            let existingCount = 1;\n            // Check if there's already a count indicator\n            const countMatch = fullMealText.match(/^(.*)\\s+×\\s+(\\d+)$/);\n            if (countMatch) {\n                mealName = countMatch[1];\n                existingCount = parseInt(countMatch[2]);\n                console.log(`Found existing count for ${mealName}: ${existingCount}`);\n            }\n            const key = mealName.toLowerCase();\n            // Check if we've seen this meal before\n            if (!mergedMeals[key]) {\n                mergedMeals[key] = { mealName, count: existingCount, firstIndex: index };\n                console.log(`First instance of ${mealName}, count: ${existingCount}`);\n            }\n            else {\n                mergedMeals[key].count += existingCount;\n                console.log(`Added ${existingCount} to ${mealName}, new count: ${mergedMeals[key].count}`);\n            }\n        }\n        else if (!line.toLowerCase().startsWith(\"-\") && line.includes(':')) {\n            const match = line.match(/^([^:]+):\\s*([\\d\\.]+)g$/i);\n            if (match) {\n                const foodName = match[1].trim();\n                const serving = parseFloat(match[2]);\n                const key = foodName.toLowerCase();\n                if (isNaN(serving))\n                    return;\n                if (!mergedFood[key]) {\n                    mergedFood[key] = { foodName, totalServing: serving, firstIndex: index };\n                }\n                else {\n                    mergedFood[key].totalServing += serving;\n                }\n            }\n        }\n    });\n    const output = [];\n    lines.forEach((line, index) => {\n        if (line.toLowerCase().startsWith(\"meal:\")) {\n            const fullMealText = line.substring(5).trim();\n            let mealName = fullMealText;\n            // Check if there's already a count indicator\n            const countMatch = fullMealText.match(/^(.*)\\s+×\\s+(\\d+)$/);\n            if (countMatch) {\n                mealName = countMatch[1];\n            }\n            const key = mealName.toLowerCase();\n            if (mergedMeals[key] && mergedMeals[key].firstIndex === index) {\n                // Add the meal with a count indicator if count > 1\n                if (mergedMeals[key].count > 1) {\n                    output.push(`meal:${mealName} × ${mergedMeals[key].count}`);\n                    console.log(`Output: meal:${mealName} × ${mergedMeals[key].count}`);\n                }\n                else {\n                    output.push(`meal:${mealName}`);\n                }\n            }\n            // Skip this meal if it's not the first instance\n        }\n        else if (!line.toLowerCase().startsWith(\"-\") && line.includes(':')) {\n            const match = line.match(/^([^:]+):\\s*([\\d\\.]+)g$/i);\n            if (match) {\n                const key = match[1].trim().toLowerCase();\n                if (mergedFood[key] && mergedFood[key].firstIndex === index) {\n                    output.push(`${mergedFood[key].foodName}:${mergedFood[key].totalServing}g`);\n                }\n                return;\n            }\n            output.push(line);\n        }\n        else if (!line.toLowerCase().startsWith(\"-\")) {\n            output.push(line);\n        }\n    });\n    console.log(\"mergeMacroLines output:\", output);\n    return output;\n}\n/**\n * extractServingSize\n * ------------------\n * Extracts the serving size from a food description.\n * Returns the concatenated number and unit if found, otherwise \"Unknown\".\n */\nexport function extractServingSize(description) {\n    try {\n        const regex = /Per\\s*(\\d+(\\.\\d+)?)\\s*(g|medium|large|slice|cup|tbsp|oz)/i;\n        const match = description.match(regex);\n        return match ? `${match[1]}${match[3]}` : 'Unknown';\n    }\n    catch (error) {\n        console.error('Error extracting serving size:', error);\n        return 'Unknown';\n    }\n}\n/**\n * extractNutritionalData\n * ----------------------\n * Extracts nutritional information (calories, fat, carbs, and protein) from a food description.\n * Returns the numeric value if found; otherwise \"N/A\".\n */\nexport function extractNutritionalData(description) {\n    try {\n        const caloriesMatch = description.match(/Calories:\\s*(\\d+(\\.\\d+)?)kcal/i);\n        const fatMatch = description.match(/Fat:\\s*(\\d+(\\.\\d+)?)g/i);\n        const carbsMatch = description.match(/Carbs:\\s*(\\d+(\\.\\d+)?)g/i);\n        const proteinMatch = description.match(/Protein:\\s*(\\d+(\\.\\d+)?)g/i);\n        return {\n            calories: caloriesMatch ? caloriesMatch[1] : 'N/A',\n            fat: fatMatch ? fatMatch[1] : 'N/A',\n            carbs: carbsMatch ? carbsMatch[1] : 'N/A',\n            protein: proteinMatch ? proteinMatch[1] : 'N/A',\n        };\n    }\n    catch (error) {\n        console.error('Error extracting nutritional data:', error);\n        return { calories: 'N/A', fat: 'N/A', carbs: 'N/A', protein: 'N/A' };\n    }\n}\n/**\n * parseGrams\n * ----------\n * Extracts a numeric value (in grams) from a text string.\n */\nexport function parseGrams(value) {\n    const match = value.match(/(\\d+(\\.\\d+)?)/);\n    return match ? parseFloat(match[0]) : NaN;\n}\n/**\n * normalizeName\n * -------------\n * Normalizes a food name for case-insensitive comparison.\n */\nexport function normalizeName(name) {\n    return name.toLowerCase().replace(/[^a-z0-9]/g, '');\n}\n/**\n * findMatchingFoodFile\n * --------------------\n * Finds a matching food file based on a query.\n */\nexport function findMatchingFoodFile(files, foodQuery) {\n    const queryLower = foodQuery.toLowerCase();\n    // Try to find an exact match ignoring the .md extension.\n    const exactMatches = files.filter(f => f.name.replace(/\\.md$/, '').toLowerCase() === queryLower);\n    if (exactMatches.length === 1)\n        return exactMatches[0];\n    // If no exact match, try partial match.\n    const partialMatches = files.filter(f => f.name.toLowerCase().includes(queryLower));\n    if (partialMatches.length === 1)\n        return partialMatches[0];\n    if (partialMatches.length > 1) {\n        console.warn(`Ambiguous food query \"${foodQuery}\" matches multiple files. Please disambiguate.`);\n        return null;\n    }\n    return null;\n}\n/**\n * processNutritionalData\n * ----------------------\n * Process nutritional data for a food item, scaling by quantity if provided.\n */\nexport function processNutritionalData(app, foodFile, specifiedQuantity = null) {\n    const cache = app.metadataCache.getFileCache(foodFile);\n    if (!cache || !cache.frontmatter)\n        return null;\n    const fm = cache.frontmatter;\n    const storedServing = fm['serving_size'] || '';\n    if (!storedServing.toLowerCase().includes('g'))\n        return null;\n    const storedServingGrams = parseGrams(storedServing);\n    if (isNaN(storedServingGrams))\n        return null;\n    const quantity = (specifiedQuantity != null && !isNaN(specifiedQuantity))\n        ? specifiedQuantity\n        : storedServingGrams;\n    const scale = quantity / storedServingGrams;\n    const cal = parseFloat(fm['calories']) || 0;\n    const prot = parseFloat(fm['protein']) || 0;\n    const fat = parseFloat(fm['fat']) || 0;\n    const carbs = parseFloat(fm['carbs']) || 0;\n    return {\n        name: foodFile.name.replace(/\\.md$/, ''),\n        serving: `${quantity}g`,\n        calories: cal * scale,\n        protein: prot * scale,\n        fat: fat * scale,\n        carbs: carbs * scale\n    };\n}\n/**\n * Calculates the pie chart angles for a set of slices\n */\nexport function calculatePieChartAngles(slices) {\n    const total = slices.reduce((sum, slice) => sum + slice.value, 0);\n    if (total <= 0)\n        return [];\n    let angles = slices.map(slice => (slice.value / total) * 2 * Math.PI);\n    const sumAngles = angles.reduce((acc, val) => acc + val, 0);\n    const angleDiff = 2 * Math.PI - sumAngles;\n    if (angles.length > 0)\n        angles[angles.length - 1] += angleDiff;\n    return angles;\n}\n/**\n * Renders a pie chart for macronutrients\n */\nexport function renderMacronutrientPieChart(ctx, protein, fat, carbs, proteinColor, fatColor, carbsColor) {\n    const centerX = 150;\n    const centerY = 150;\n    const radius = 150;\n    const slices = [\n        { label: 'Protein', value: protein, color: proteinColor },\n        { label: 'Fat', value: fat, color: fatColor },\n        { label: 'Carbs', value: carbs, color: carbsColor },\n    ];\n    const sumMacros = protein + fat + carbs;\n    if (sumMacros <= 0) {\n        return false;\n    }\n    let startAngle = 0;\n    slices.forEach(slice => {\n        const fraction = slice.value / sumMacros;\n        const sliceAngle = fraction * 2 * Math.PI;\n        ctx.beginPath();\n        ctx.moveTo(centerX, centerY);\n        ctx.arc(centerX, centerY, radius, startAngle, startAngle + sliceAngle);\n        ctx.closePath();\n        ctx.fillStyle = slice.color;\n        ctx.fill();\n        startAngle += sliceAngle;\n    });\n    return true;\n}\n/**\n * Creates a legend for a pie chart\n */\nexport function createPieChartLegend(el, slices) {\n    const legendDiv = el.createEl('div', {\n        cls: 'macrospc-legend',\n        attr: { style: 'margin-top: 1em;' }\n    });\n    slices.forEach(slice => {\n        const legendItem = legendDiv.createEl('div', {\n            cls: 'macrospc-legend-item',\n            attr: { style: 'display: flex; align-items: center; margin-bottom: 2px;' }\n        });\n        const colorBox = legendItem.createEl('span');\n        colorBox.style.backgroundColor = slice.color;\n        colorBox.style.display = 'inline-block';\n        colorBox.style.width = '12px';\n        colorBox.style.height = '12px';\n        colorBox.style.marginRight = '5px';\n        legendItem.createEl('span', { text: `${slice.label}: ${slice.value.toFixed(2)} g` });\n    });\n    return legendDiv;\n}\n","references":["C:/Users/James/Desktop/obsidian-macros-plugin/types/obsidian.d.ts"]}
