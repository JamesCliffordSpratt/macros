{"code":"import { __awaiter } from \"tslib\";\nimport { parseGrams, findMatchingFoodFile, processNutritionalData } from './utils';\nimport { AddToMacrosModal } from './modals';\n/*\n * Markdown Processors for Macros Plugin\n * ------------------------------------------------\n * Registers custom markdown processors that dynamically render nutritional data.\n * Processors include:\n *  - 'macros': Renders editable macros blocks for food items and meals.\n *  - 'macrospc': Draws pie charts representing the macronutrient breakdown.\n *  - 'macroscalc': Aggregates nutritional data and displays detailed calculations.\n */\nexport function registerProcessors(plugin) {\n    /**\n     * Macros Processor\n     * ----------------\n     * Registers a markdown code block processor for rendering and editing a macros block.\n     *\n     * Expected Input:\n     * - The first line should specify an \"id:\" declaration.\n     * - The remaining lines contain macro definitions.\n     */\n    plugin.registerMarkdownCodeBlockProcessor('macros', (source, el) => __awaiter(this, void 0, void 0, function* () {\n        // Split, trim, and get the id value from the first line.\n        let lines = source.split(\"\\n\").map(l => l.trim()).filter(l => l !== '');\n        let id = null;\n        if (lines.length && /^id:\\s*(\\S+)/i.test(lines[0])) {\n            const match = lines[0].match(/^id:\\s*(\\S+)/i);\n            if (match) {\n                id = match[1];\n                lines.shift();\n            }\n        }\n        if (id) {\n            // Store only non-bullet point lines in the global macro tables\n            const nonBulletLines = lines.filter(l => !l.startsWith('-'));\n            plugin.macroTables.set(id, nonBulletLines);\n        }\n        // refreshTable re-renders the macros table from the file.\n        const refreshTable = () => __awaiter(this, void 0, void 0, function* () {\n            const activeFile = plugin.app.workspace.getActiveFile();\n            if (!activeFile || !id)\n                return;\n            try {\n                const content = yield plugin.app.vault.read(activeFile);\n                // Helper function to escape special regex characters in the id.\n                function escapeRegExp(str) {\n                    return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                }\n                const escapedId = escapeRegExp(id);\n                const regex = new RegExp(\"```\\\\s*macros\\\\s+id:\\\\s*\" + escapedId + \"\\\\s*\\\\n([\\\\s\\\\S]*?)```\", \"m\");\n                const match = content.match(regex);\n                if (!match)\n                    return;\n                // Include all lines for display (including bullet points)\n                let allLines = match[1].split(\"\\n\").map(l => l.trim()).filter(l => l !== '');\n                renderTableFromLines(allLines);\n            }\n            catch (error) {\n                console.error('Error refreshing table:', error);\n            }\n        });\n        const renderTableFromLines = (lines) => {\n            el.empty();\n            const table = el.createEl('table');\n            table.style.width = '100%';\n            // Add a row with a \"+\" button.\n            const plusRow = table.insertRow();\n            const plusCell = plusRow.insertCell();\n            plusCell.colSpan = 6;\n            plusCell.style.textAlign = 'right';\n            const plusBtn = plusCell.createEl('button', { text: '+' });\n            plusBtn.style.fontSize = '1.2em';\n            plusBtn.style.cursor = 'pointer';\n            plusBtn.onclick = () => {\n                new AddToMacrosModal(plugin.app, plugin, id, () => __awaiter(this, void 0, void 0, function* () {\n                    yield plugin.updateMacrosCodeBlock();\n                    yield refreshTable();\n                })).open();\n            };\n            const groups = [];\n            const otherGroup = {\n                name: 'Other Items',\n                count: 1,\n                rows: [],\n                total: { calories: 0, protein: 0, fat: 0, carbs: 0 },\n            };\n            function processItem(foodQuery, specifiedQuantity) {\n                const matchingFile = findMatchingFoodFile(plugin.getFilesInFolder(plugin.settings.storageFolder), foodQuery);\n                if (!matchingFile)\n                    return null;\n                const nutrition = processNutritionalData(plugin.app, matchingFile, specifiedQuantity);\n                if (!nutrition)\n                    return null;\n                return {\n                    name: nutrition.name,\n                    serving: nutrition.serving,\n                    calories: nutrition.calories,\n                    protein: nutrition.protein,\n                    fat: nutrition.fat,\n                    carbs: nutrition.carbs,\n                    macroLine: foodQuery + (specifiedQuantity ? ':' + specifiedQuantity + 'g' : '')\n                };\n            }\n            lines.forEach(line => {\n                if (line.toLowerCase().startsWith('meal:')) {\n                    // Extract the meal name and potential count information\n                    const fullMealText = line.substring(5).trim();\n                    let mealName = fullMealText;\n                    let count = 1;\n                    // Check if there's a count indicator\n                    const countMatch = fullMealText.match(/^(.*)\\s+×\\s+(\\d+)$/);\n                    if (countMatch) {\n                        mealName = countMatch[1];\n                        count = parseInt(countMatch[2]);\n                    }\n                    // Use MealTemplate type for meal comparison.\n                    const meal = plugin.settings.mealTemplates.find(m => m.name.toLowerCase() === mealName.toLowerCase());\n                    if (!meal)\n                        return;\n                    const group = {\n                        name: mealName,\n                        count: count,\n                        rows: [],\n                        total: { calories: 0, protein: 0, fat: 0, carbs: 0 },\n                        macroLine: line\n                    };\n                    meal.items.forEach((item) => {\n                        let foodQuery = item;\n                        let specifiedQuantity = null;\n                        if (item.includes(':')) {\n                            const parts = item.split(':').map(s => s.trim());\n                            foodQuery = parts[0];\n                            specifiedQuantity = parseGrams(parts[1]);\n                            // Multiply by count if there's a multiplier\n                            if (count > 1 && specifiedQuantity !== null) {\n                                specifiedQuantity = specifiedQuantity * count;\n                            }\n                        }\n                        const row = processItem(foodQuery, specifiedQuantity);\n                        if (row) {\n                            row.macroLine = item;\n                            group.rows.push(row);\n                            group.total.calories += row.calories;\n                            group.total.protein += row.protein;\n                            group.total.fat += row.fat;\n                            group.total.carbs += row.carbs;\n                        }\n                    });\n                    groups.push(group);\n                }\n                else if (line.startsWith('-')) {\n                    // Skip bullet points as they're just visual representations\n                    return;\n                }\n                else {\n                    let foodQuery = line;\n                    let specifiedQuantity = null;\n                    if (line.includes(':')) {\n                        const parts = line.split(':').map(s => s.trim());\n                        foodQuery = parts[0];\n                        specifiedQuantity = parseGrams(parts[1]);\n                    }\n                    const row = processItem(foodQuery, specifiedQuantity);\n                    if (row) {\n                        row.macroLine = line;\n                        otherGroup.rows.push(row);\n                        otherGroup.total.calories += row.calories;\n                        otherGroup.total.protein += row.protein;\n                        otherGroup.total.fat += row.fat;\n                        otherGroup.total.carbs += row.carbs;\n                    }\n                }\n            });\n            if (otherGroup.rows.length > 0)\n                groups.push(otherGroup);\n            const multipleGroups = groups.length > 1;\n            groups.forEach(group => {\n                const headerRow = table.insertRow();\n                const headerCell = headerRow.insertCell();\n                headerCell.colSpan = 6;\n                headerCell.style.fontWeight = 'bold';\n                // Add quantity indicator in the header if count > 1\n                if (group.count > 1) {\n                    headerCell.innerText = `${group.name} × ${group.count}`;\n                }\n                else {\n                    headerCell.innerText = group.name;\n                }\n                if (group.macroLine) {\n                    const removeBtn = headerCell.createEl('button', { text: ' –' });\n                    removeBtn.style.marginLeft = '8px';\n                    removeBtn.onclick = () => __awaiter(this, void 0, void 0, function* () {\n                        yield removeMacroLine(group.macroLine);\n                    });\n                }\n                const colHeaderRow = table.insertRow();\n                ['Food', 'Quantity', 'Calories', 'Protein', 'Fat', 'Carbs'].forEach((text) => {\n                    const cell = colHeaderRow.insertCell();\n                    cell.innerText = text;\n                    cell.style.fontWeight = 'bold';\n                });\n                group.rows.forEach((row) => {\n                    const r = table.insertRow();\n                    const nameCell = r.insertCell();\n                    nameCell.innerText = row.name;\n                    if (!group.macroLine) {\n                        const removeBtn = nameCell.createEl('button', { text: ' –' });\n                        removeBtn.style.marginLeft = '5px';\n                        removeBtn.onclick = () => __awaiter(this, void 0, void 0, function* () {\n                            yield removeMacroLine(row.macroLine);\n                        });\n                    }\n                    r.insertCell().innerText = row.serving;\n                    r.insertCell().innerText = row.calories.toFixed(2);\n                    r.insertCell().innerText = row.protein.toFixed(2);\n                    r.insertCell().innerText = row.fat.toFixed(2);\n                    r.insertCell().innerText = row.carbs.toFixed(2);\n                });\n                if (!multipleGroups) {\n                    const totalRow = table.insertRow();\n                    totalRow.insertCell().innerText = 'Totals';\n                    totalRow.insertCell().innerText = '';\n                    totalRow.insertCell().innerText = group.total.calories.toFixed(2);\n                    totalRow.insertCell().innerText = group.total.protein.toFixed(2);\n                    totalRow.insertCell().innerText = group.total.fat.toFixed(2);\n                    totalRow.insertCell().innerText = group.total.carbs.toFixed(2);\n                }\n            });\n            if (groups.length > 1) {\n                let combinedTotals = { calories: 0, protein: 0, fat: 0, carbs: 0 };\n                groups.forEach(g => {\n                    combinedTotals.calories += g.total.calories;\n                    combinedTotals.protein += g.total.protein;\n                    combinedTotals.fat += g.total.fat;\n                    combinedTotals.carbs += g.total.carbs;\n                });\n                const combinedHeaderRow = table.insertRow();\n                const combinedHeaderCell = combinedHeaderRow.insertCell();\n                combinedHeaderCell.colSpan = 6;\n                combinedHeaderCell.innerText = 'Combined Totals';\n                combinedHeaderCell.style.fontWeight = 'bold';\n                const combinedTotalsRow = table.insertRow();\n                combinedTotalsRow.insertCell().innerText = 'Totals';\n                combinedTotalsRow.insertCell().innerText = '';\n                combinedTotalsRow.insertCell().innerText = combinedTotals.calories.toFixed(2);\n                combinedTotalsRow.insertCell().innerText = combinedTotals.protein.toFixed(2);\n                combinedTotalsRow.insertCell().innerText = combinedTotals.fat.toFixed(2);\n                combinedTotalsRow.insertCell().innerText = combinedTotals.carbs.toFixed(2);\n            }\n            const removeMacroLine = (macroLine) => __awaiter(this, void 0, void 0, function* () {\n                const activeFile = plugin.app.workspace.getActiveFile();\n                if (!activeFile)\n                    return;\n                try {\n                    let content = yield plugin.app.vault.read(activeFile);\n                    if (!id)\n                        return;\n                    const regex = new RegExp(\"```macros\\\\s+id:\\\\s*\" + id + \"\\\\s*([\\\\s\\\\S]*?)```\", \"m\");\n                    const match = content.match(regex);\n                    if (!match)\n                        return;\n                    let blockLines = match[1].split(\"\\n\").map(l => l.trim());\n                    // Updated removal logic: if removing a meal, skip the meal header and all immediately following lines starting with \"-\"\n                    let newBlockLines = [];\n                    if (macroLine.toLowerCase().startsWith(\"meal:\")) {\n                        const index = blockLines.findIndex(l => l === macroLine);\n                        if (index === -1)\n                            return;\n                        // Keep lines before the meal header.\n                        newBlockLines = blockLines.slice(0, index);\n                        // Skip all subsequent lines that are food items (start with \"-\")\n                        let j = index + 1;\n                        while (j < blockLines.length && blockLines[j].startsWith(\"-\")) {\n                            j++;\n                        }\n                        // Append remaining lines.\n                        newBlockLines = newBlockLines.concat(blockLines.slice(j));\n                    }\n                    else {\n                        newBlockLines = blockLines.filter(line => line !== macroLine);\n                    }\n                    const newBlock = \"```macros\\nid: \" + id + \"\\n\" + newBlockLines.join(\"\\n\") + \"\\n```\";\n                    content = content.replace(regex, newBlock);\n                    yield plugin.app.vault.modify(activeFile, content);\n                    // This is the key change - now we're properly filtering out bullet points \n                    plugin.updateGlobalMacroTableFromContent(content);\n                    yield refreshTable();\n                    yield plugin.redrawAllMacrospc();\n                    yield plugin.redrawAllMacrocalc();\n                }\n                catch (error) {\n                    console.error(\"Error removing macro line:\", error);\n                }\n            });\n            el.appendChild(table);\n        };\n        yield refreshTable();\n    }));\n    /**\n     * MacrosPC Processor\n     * ------------------\n     * Registers a markdown code block processor for rendering a pie chart (macrospc) that visualizes the\n     * distribution of macronutrients based on a macros table.\n     *\n     * Expected Input:\n     * - The code block should provide an \"id:\" or \"ids:\" declaration.\n     */\n    plugin.registerMarkdownCodeBlockProcessor('macrospc', (source, el) => __awaiter(this, void 0, void 0, function* () {\n        let lines = source.split(\"\\n\").map(l => l.trim()).filter(l => l !== '');\n        let ids = [];\n        if (lines.length && /^ids:\\s*(.+)/i.test(lines[0])) {\n            const match = lines[0].match(/^ids:\\s*(.+)/i);\n            if (match) {\n                ids = match[1].split(\",\").map(s => s.trim()).filter(s => s.length > 0);\n            }\n        }\n        else if (lines.length && /^id:\\s*(\\S+)/i.test(lines[0])) {\n            const match = lines[0].match(/^id:\\s*(\\S+)/i);\n            if (match) {\n                ids.push(match[1]);\n            }\n        }\n        el.empty();\n        if (ids.length === 0) {\n            el.createEl('div', { text: 'No id(s) provided in macrospc block' });\n            return;\n        }\n        // For each id, load external macros if not cached.\n        for (const id of ids) {\n            if (!plugin.macroTables.has(id)) {\n                const loaded = yield plugin.loadMacroTableFromVault(id);\n                if (loaded) {\n                    plugin.macroTables.set(id, loaded);\n                }\n                else {\n                    el.createEl('div', { text: `Warning: Table with id \"${id}\" not found.` });\n                }\n            }\n        }\n        if (ids.length === 1) {\n            const id = ids[0];\n            if (!plugin.macrospcContainers.has(id)) {\n                plugin.macrospcContainers.set(id, new Set());\n            }\n            plugin.macrospcContainers.get(id).add(el);\n            plugin.drawMacrospc(id, el);\n        }\n        else {\n            plugin.drawCombinedMacrospc(ids, el);\n        }\n    }));\n    /**\n     * MacrosCalc Processor\n     * --------------------\n     * Registers a markdown code block processor for calculating and displaying aggregated nutritional data.\n     *\n     * Expected Input:\n     * - The code block should include a line specifying table IDs using \"ids:\".\n     */\n    plugin.registerMarkdownCodeBlockProcessor('macroscalc', (source, el) => __awaiter(this, void 0, void 0, function* () {\n        let lines = source.split(\"\\n\").map(l => l.trim()).filter(l => l !== '');\n        if (lines.length === 0) {\n            el.createEl('div', { text: 'Error: No content provided in macroscalc block.' });\n            return;\n        }\n        let idsLine = lines.find(line => line.toLowerCase().startsWith(\"ids:\"));\n        if (!idsLine) {\n            el.createEl('div', { text: 'Error: Please specify table IDs using \"ids:\"' });\n            return;\n        }\n        idsLine = idsLine.substring(4).trim();\n        const ids = idsLine.split(\",\").map(s => s.trim()).filter(s => s.length > 0);\n        if (ids.length === 0) {\n            el.createEl('div', { text: 'Error: No table IDs provided.' });\n            return;\n        }\n        // For each id, load its table if not cached.\n        for (const id of ids) {\n            if (!plugin.macroTables.has(id)) {\n                const tableLines = yield plugin.loadMacroTableFromVault(id);\n                if (tableLines) {\n                    plugin.macroTables.set(id, tableLines);\n                }\n            }\n        }\n        let aggregate = { calories: 0, protein: 0, fat: 0, carbs: 0 };\n        const breakdown = [];\n        function processFoodItem(foodQuery, specifiedQuantity) {\n            const matchingFile = findMatchingFoodFile(plugin.getFilesInFolder(plugin.settings.storageFolder), foodQuery);\n            if (!matchingFile)\n                return { calories: 0, protein: 0, fat: 0, carbs: 0 };\n            const nutrition = processNutritionalData(plugin.app, matchingFile, specifiedQuantity);\n            return nutrition || { calories: 0, protein: 0, fat: 0, carbs: 0 };\n        }\n        for (const id of ids) {\n            let total = { calories: 0, protein: 0, fat: 0, carbs: 0 };\n            const tableLines = plugin.macroTables.get(id);\n            if (!tableLines)\n                continue;\n            for (const line of tableLines) {\n                if (line.toLowerCase().startsWith(\"meal:\")) {\n                    // Extract meal name and count if present\n                    const fullMealText = line.substring(5).trim();\n                    let mealName = fullMealText;\n                    let count = 1;\n                    // Check if there's a count indicator\n                    const countMatch = fullMealText.match(/^(.*)\\s+×\\s+(\\d+)$/);\n                    if (countMatch) {\n                        mealName = countMatch[1];\n                        count = parseInt(countMatch[2]);\n                    }\n                    const meal = plugin.settings.mealTemplates.find(m => m.name.toLowerCase() === mealName.toLowerCase());\n                    if (!meal)\n                        continue;\n                    // Process each food item in the meal template\n                    for (const item of meal.items) {\n                        let foodQuery = item;\n                        let specifiedQuantity = null;\n                        if (item.includes(':')) {\n                            const parts = item.split(':').map(s => s.trim());\n                            foodQuery = parts[0];\n                            specifiedQuantity = parseGrams(parts[1]);\n                            // Apply multiplier if count > 1\n                            if (count > 1 && specifiedQuantity !== null) {\n                                specifiedQuantity = specifiedQuantity * count;\n                            }\n                        }\n                        const result = processFoodItem(foodQuery, specifiedQuantity);\n                        total.calories += result.calories;\n                        total.protein += result.protein;\n                        total.fat += result.fat;\n                        total.carbs += result.carbs;\n                    }\n                }\n                else if (!line.startsWith('-')) {\n                    let foodQuery = line;\n                    let specifiedQuantity = null;\n                    if (line.includes(':')) {\n                        const parts = line.split(':').map(s => s.trim());\n                        foodQuery = parts[0];\n                        specifiedQuantity = parseGrams(parts[1]);\n                    }\n                    const result = processFoodItem(foodQuery, specifiedQuantity);\n                    total.calories += result.calories;\n                    total.protein += result.protein;\n                    total.fat += result.fat;\n                    total.carbs += result.carbs;\n                }\n            }\n            breakdown.push({ id, totals: total });\n            aggregate.calories += total.calories;\n            aggregate.protein += total.protein;\n            aggregate.fat += total.fat;\n            aggregate.carbs += total.carbs;\n        }\n        const table = el.createEl('table');\n        table.style.width = '100%';\n        const headerRow = table.insertRow();\n        ['Table ID', 'Calories', 'Protein', 'Fat', 'Carbs'].forEach(text => {\n            const cell = headerRow.insertCell();\n            cell.innerText = text;\n            cell.style.fontWeight = 'bold';\n        });\n        breakdown.forEach(item => {\n            const row = table.insertRow();\n            row.insertCell().innerText = item.id;\n            row.insertCell().innerText = item.totals.calories.toFixed(2);\n            row.insertCell().innerText = item.totals.protein.toFixed(2);\n            row.insertCell().innerText = item.totals.fat.toFixed(2);\n            row.insertCell().innerText = item.totals.carbs.toFixed(2);\n        });\n        const aggregateRow = table.insertRow();\n        aggregateRow.insertCell().innerText = 'Aggregate Totals';\n        aggregateRow.insertCell().innerText = aggregate.calories.toFixed(2);\n        aggregateRow.insertCell().innerText = aggregate.protein.toFixed(2);\n        aggregateRow.insertCell().innerText = aggregate.fat.toFixed(2);\n        aggregateRow.insertCell().innerText = aggregate.carbs.toFixed(2);\n        el.appendChild(table);\n    }));\n}\n","references":["C:/Users/James/Desktop/obsidian-macros-plugin/types/obsidian.d.ts","C:/Users/James/Desktop/obsidian-macros-plugin/utils.ts","C:/Users/James/Desktop/obsidian-macros-plugin/modals.ts","C:/Users/James/Desktop/obsidian-macros-plugin/main.ts"]}
